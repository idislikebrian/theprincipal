const { default: Youtube } = require('youtube-sr');
const ytdl = require('ytdl-core');
const SpotifyWebApi = require('spotify-web-api-node');
const spotifyApi = new SpotifyWebApi({ clientId: '544109f2efdc4f6f9e429ca74bdacc9f', clientSecret: '8c05fc01247a4683ad09c3583e796ab4' });
const fetch = require('node-fetch');

const parse = (url) => {
  return url.split('?')[0];
}

const spdl = async (url) => {
  return new Promise(async (resolve, reject) => {
    if (!SPDLCore.validateURL(url)) return reject('Invalid URL');
    try {
      const data = await fetch('https://accounts.spotify.com/api/token?grant_type=client_credentials', {
        method: 'POST',
        headers: {
          authorization: `Basic ${Buffer.from(`${spotifyApi.getCredentials().clientId}:${spotifyApi.getCredentials().clientSecret}`).toString('base64')}`,
          'Content-Type': 'application/x-www-form-urlencoded'
        }
      }).catch(err => reject(err));
      const json = await data.json();
      spotifyApi.setAccessToken(json.access_token);
    } catch (err) {
      return reject(err);
    }
    const infos = await spotifyApi.getTrack(SPDLCore.getURLTrackID(url)).catch(err => reject(err));
    if (!infos) return reject('Track not found');
    let video = await Youtube.searchOne(`${infos.body.name} ${infos.body.artists[0].name}`);
    if (!video) video = await Youtube.searchOne(`${infos.body.name}`);
    if (!video || video.views === 0) return reject('Track not found');
    return resolve(ytdl(video.url));
  });
}

class SPDLCore {
  static async getInfo(url) {
    return new Promise(async (resolve, reject) => {
      if (!this.validateURL(url)) return reject('Invalid URL');
      try {
        const data = await fetch('https://accounts.spotify.com/api/token?grant_type=client_credentials', {
          method: 'POST',
          headers: {
            authorization: `Basic ${Buffer.from(`${spotifyApi.getCredentials().clientId}:${spotifyApi.getCredentials().clientSecret}`).toString('base64')}`,
            'Content-Type': 'application/x-www-form-urlencoded'
          }
        }).catch(err => reject(err));
        const json = await data.json();
        spotifyApi.setAccessToken(json.access_token);
      } catch (err) {
        return reject(err);
      }
      const infos = await spotifyApi.getTrack(this.getURLTrackID(url)).catch(err => reject(err));
      if (!infos) return reject('Track not found');
      return resolve({
        title: infos.body.name,
        artist: infos.body.artists.map(a => a.name),
        url: infos.body.external_urls.spotify,
        id: infos.body.id,
        uri: infos.body.uri
      });
    });
  }

  static validateURL(url) {
    return /^https?:\/\/(?:open|play)\.spotify\.com\/track\/[\w\d]+$/i.test(parse(url));
  }
  
  static setCredentials(clientId, clientSecret) {
    spotifyApi.setCredentials({
      clientSecret,
      clientId
    });
  }

  static setClientId(clientId) {
    spotifyApi.setClientId(clientId);
  }

  static setClientSecret(clientSecret) {
    spotifyApi.setClientSecret(clientSecret);
  }

  static getURLTrackID(url) {
    if (!this.validateURL(url)) throw new Error('Invalid URL');
    return parse(url).split('track/')[1];
  }
}

spdl.validateURL = SPDLCore.validateURL;
spdl.getInfo = SPDLCore.getInfo;
spdl.getURLTrackID = SPDLCore.getURLTrackID;
spdl.setCredentials = SPDLCore.setCredentials;
spdl.setClientId = SPDLCore.setClientId;
spdl.setClientSecret = SPDLCore.setClientSecret;

module.exports = spdl;