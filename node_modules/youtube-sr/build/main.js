"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YouTube = exports.Video = exports.Playlist = exports.Channel = exports.Thumbnail = exports.Util = void 0;
const Util_1 = __importDefault(require("./Util"));
exports.Util = Util_1.default;
const Channel_1 = __importDefault(require("./Structures/Channel"));
exports.Channel = Channel_1.default;
const Playlist_1 = __importDefault(require("./Structures/Playlist"));
exports.Playlist = Playlist_1.default;
const Video_1 = __importDefault(require("./Structures/Video"));
exports.Video = Video_1.default;
const Thumbnail_1 = __importDefault(require("./Structures/Thumbnail"));
exports.Thumbnail = Thumbnail_1.default;
class YouTube {
    constructor() {
        throw new Error(`The ${this.constructor.name} class may not be instantiated!`);
    }
    static async search(query, options) {
        if (!options)
            options = { limit: 20, type: "video", requestOptions: {} };
        if (!query || typeof query !== "string")
            throw new Error(`Invalid search query "${query}"!`);
        const url = `https://youtube.com/results?q=${encodeURI(query.trim())}&hl=en`;
        const html = await Util_1.default.getHTML(url, options.requestOptions);
        return Util_1.default.parseSearchResult(html, options);
    }
    static searchOne(query, type, requestOptions) {
        if (!type)
            type = "video";
        return new Promise((resolve) => {
            // @ts-ignore
            YouTube.search(query, { limit: 1, type: type, requestOptions: requestOptions })
                .then(res => {
                if (!res || !res.length)
                    return resolve(null);
                resolve(res[0]);
            })
                .catch(e => {
                resolve(null);
            });
        });
    }
    /**
     * Returns playlist details
     * @param {string} url Playlist URL
     * @param {object} [options] Options
     * @param {number} [options.limit=100] Playlist video limit
     * @param {RequestInit} [options.requestOptions] Request Options
     */
    static async getPlaylist(url, options) {
        if (!options)
            options = { limit: 100, requestOptions: {} };
        if (!url || typeof url !== "string")
            throw new Error(`Expected playlist url, received ${typeof url}!`);
        Util_1.default.validatePlaylist(url);
        url = Util_1.default.getPlaylistURL(url);
        const html = await Util_1.default.getHTML(`${url}&hl=en`, options && options.requestOptions);
        try {
            return Util_1.default.getPlaylist(html, options && options.limit);
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Validates playlist
     * @param {string} url Playlist id or url/video id or url to validate
     * @param {"VIDEO"|"VIDEO_ID"|"PLAYLIST"|"PLAYLIST_ID"} type URL validation type
     * @returns {boolean}
     */
    static validate(url, type) {
        if (typeof url !== "string")
            return false;
        if (!type)
            type = "PLAYLIST";
        switch (type) {
            case "PLAYLIST":
                return this.Regex.PLAYLIST_URL.test(url);
            case "PLAYLIST_ID":
                return this.Regex.PLAYLIST_ID.test(url);
            case "VIDEO":
                return this.Regex.VIDEO_URL.test(url);
            case "VIDEO_ID":
                return this.Regex.VIDEO_ID.test(url);
            default:
                return false;
        }
    }
    static get Regex() {
        return {
            PLAYLIST_URL: Util_1.default.PlaylistURLRegex,
            PLAYLIST_ID: Util_1.default.PlaylistIDRegex,
            VIDEO_ID: /^[a-zA-Z0-9-_]{11}$/,
            VIDEO_URL: /^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$/
        };
    }
}
exports.YouTube = YouTube;
exports.default = YouTube;
